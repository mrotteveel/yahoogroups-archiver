package nl.lawinegevaar.yahoogroups.database;

import lombok.extern.slf4j.Slf4j;

import java.sql.*;

@Slf4j
public class DatabaseInitializer {

    private final DatabaseInfo databaseInfo;

    public DatabaseInitializer(DatabaseInfo databaseInfo) {
        this.databaseInfo = databaseInfo;
    }

    public void initializeDatabase() {
        createDatabase();

        try (Connection connection = databaseInfo.getConnection()) {
            migrateDatabase(connection);
        } catch (SQLException e) {
            throw new DatabaseInitializationFailureException("Unable to connect to database", e);
        }
    }

    private void migrateDatabase(Connection connection) {
        try {
            int dbVersion = findDatabaseVersion(connection);
            log.info("Found database version: {}", dbVersion);
            connection.setAutoCommit(false);

            switch (dbVersion) {
                case 0:
                    new MigrationStep(1, connection,
//@formatter:off
                            "alter database set default character set UTF8",
                            "commit",
                            "create table dbversion ( " +
                            "    version integer constraint pk_dbversion primary key, " +
                            "    migration_date timestamp default current_timestamp not null " +
                            ")",
                            // force commit so version update succeeds
                            "commit"
//@formatter:on
                    ).migrate();

                case 1:
                    new MigrationStep(2, connection,
//@formatter:off
                            "create table ygroup ( " +
                            "    id integer generated by default as identity constraint pk_ygroup primary key, " +
                            "    groupname varchar(50) character set UTF8 not null constraint uq_ygroup_name unique collate UNICODE_CI " +
                            ")",
                            "create table rawdata ( " +
                            "    group_id integer not null constraint fk_rawdata_ygroup references ygroup (id), " +
                            "    message_id integer not null, " +
                            "    message_json blob sub_type text character set utf8," +
                            "    raw_message_json blob sub_type text character set utf8, " +
                            "    last_update timestamp default current_timestamp not null, " +
                            "    constraint pk_rawdata primary key (group_id, message_id) " +
                            ")"
//@formatter:on
                    ).migrate();

                case 2:
                    new MigrationStep(3, connection,
//@formatter:off
                            "create table link_info ( " +
                            "    group_id integer not null," +
                            "    message_id integer not null," +
                            "    y_topic_id integer," +
                            "    y_prev_in_topic integer," +
                            "    y_prev_in_time integer," +
                            "    post_date timestamp," +
                            "    post_year smallint generated always as (extract(year from post_date))," +
                            "    post_month smallint generated always as (extract(month from post_date))," +
                            "    constraint pk_link_info primary key (group_id, message_id)," +
                            "    constraint fk_link_info_rawdata foreign key (group_id, message_id) references rawdata (group_id, message_id)" +
                            ")"
//@formatter:on
                    ).migrate();
                case 3:
                    new MigrationStep(4, connection,
//@formatter:off
                            "CREATE VIEW POST_INFORMATION\n" +
                            "AS\n" +
                            "SELECT\n" +
                            "  a.GROUP_ID,\n" +
                            "  a.MESSAGE_ID,\n" +
                            "  a.GROUPNAME,\n" +
                            "  a.POST_DATE,\n" +
                            "  a.POST_YEAR,\n" +
                            "  a.POST_MONTH,\n" +
                            "  a.TOPIC_ID,\n" +
                            "  topic.POST_YEAR AS TOPIC_YEAR,\n" +
                            "  topic.POST_MONTH AS TOPIC_MONTH,\n" +
                            "  a.PREV_IN_TOPIC,\n" +
                            "  prev_in_topic.POST_YEAR AS PREV_IN_TOPIC_YEAR,\n" +
                            "  prev_in_topic.POST_MONTH AS PREV_IN_TOPIC_MONTH,\n" +
                            "  a.NEXT_IN_TOPIC,\n" +
                            "  next_in_topic.POST_YEAR AS NEXT_IN_TOPIC_YEAR,\n" +
                            "  next_in_topic.POST_MONTH AS NEXT_IN_TOPIC_MONTH,\n" +
                            "  a.PREV_IN_TIME,\n" +
                            "  prev_in_time.POST_YEAR AS PREV_IN_TIME_YEAR,\n" +
                            "  prev_in_time.POST_MONTH AS PREV_IN_TIME_MONTH,\n" +
                            "  a.NEXT_IN_TIME,\n" +
                            "  next_in_time.POST_YEAR AS NEXT_IN_TIME_YEAR,\n" +
                            "  next_in_time.POST_MONTH AS NEXT_IN_TIME_MONTH,\n" +
                            "  a.MESSAGE_JSON\n" +
                            "FROM (\n" +
                            "    SELECT \n" +
                            "      GROUP_ID, \n" +
                            "      MESSAGE_ID,\n" +
                            "      g.GROUPNAME,\n" +
                            "      -- Using the MESSAGE_ID as an indication of time ordering between messages, not the POST_DATE\n" +
                            "      FIRST_VALUE(MESSAGE_ID) OVER (PARTITION BY GROUP_ID, li.Y_TOPIC_ID ORDER BY MESSAGE_ID) AS TOPIC_ID,\n" +
                            "      LAG(MESSAGE_ID) OVER (PARTITION BY GROUP_ID, li.Y_TOPIC_ID ORDER BY MESSAGE_ID) AS PREV_IN_TOPIC,\n" +
                            "      LEAD(MESSAGE_ID) OVER (PARTITION BY GROUP_ID, li.Y_TOPIC_ID ORDER BY MESSAGE_ID) AS NEXT_IN_TOPIC,\n" +
                            "      LAG(MESSAGE_ID) OVER (PARTITION BY GROUP_ID ORDER BY MESSAGE_ID) AS PREV_IN_TIME,\n" +
                            "      LEAD(MESSAGE_ID) OVER (PARTITION BY GROUP_ID ORDER BY MESSAGE_ID) AS NEXT_IN_TIME,\n" +
                            "      POST_DATE,\n" +
                            "      POST_YEAR,\n" +
                            "      POST_MONTH,\n" +
                            "      r.MESSAGE_JSON\n" +
                            "    FROM LINK_INFO li\n" +
                            "    INNER JOIN RAWDATA r USING (GROUP_ID, MESSAGE_ID)\n" +
                            "    INNER JOIN YGROUP g ON g.ID = GROUP_ID\n" +
                            ") a\n" +
                            "INNER JOIN LINK_INFO topic ON topic.GROUP_ID = a.GROUP_ID AND topic.MESSAGE_ID = a.TOPIC_ID\n" +
                            "LEFT JOIN LINK_INFO prev_in_topic ON prev_in_topic.GROUP_ID = a.GROUP_ID AND prev_in_topic.MESSAGE_ID = a.PREV_IN_TOPIC\n" +
                            "LEFT JOIN LINK_INFO next_in_topic ON next_in_topic.GROUP_ID = a.GROUP_ID AND next_in_topic.MESSAGE_ID = a.NEXT_IN_TOPIC \n" +
                            "LEFT JOIN LINK_INFO prev_in_time ON prev_in_time.GROUP_ID = a.GROUP_ID AND prev_in_time.MESSAGE_ID = a.PREV_IN_TIME\n" +
                            "LEFT JOIN LINK_INFO next_in_time ON next_in_time.GROUP_ID = a.GROUP_ID AND next_in_time.MESSAGE_ID = a.NEXT_IN_TIME"
//@formatter:on
                    ).migrate();
                    break;
                case 4:
                    new MigrationStep(5, connection,
//@formatter:off
                            "create view sitemap_links as\n" +
                            "select \n" +
                            "  cast('/' || y.GROUPNAME || '/index.html' as varchar(50)) as path,\n" +
                            "  LOCALTIMESTAMP as last_change \n" +
                            "from YGROUP y \n" +
                            "union all\n" +
                            "select \n" +
                            "  cast('/' || y.GROUPNAME || '/' || l.POST_YEAR || '/' || l.POST_MONTH || '/index.html' as varchar(50)) as path,\n" +
                            "  (select max(POST_DATE) from LINK_INFO li where li.GROUP_ID = l.GROUP_ID AND li.POST_YEAR = l.POST_YEAR AND li.POST_MONTH = l.POST_MONTH) as last_change\n" +
                            "from (select distinct GROUP_ID, POST_YEAR, POST_MONTH from LINK_INFO) l\n" +
                            "inner join YGROUP y on y.ID = l.GROUP_ID \n" +
                            "union all\n" +
                            "select \n" +
                            "  cast('/' || y.GROUPNAME || '/' || l.POST_YEAR || '/' || l.POST_MONTH || '/' || l.MESSAGE_ID || '.html' as varchar(50)) as path,\n" +
                            "  l.POST_DATE as last_change\n" +
                            "from LINK_INFO l\n" +
                            "inner join YGROUP y on y.ID = l.GROUP_ID "
//@formatter:on
                    ).migrate();
                    break;
                case 5:
                    // current, nothing to do
                default:
                    log.warn("Unknown or unexpected database version: {}", dbVersion);
            }

        } catch (SQLException e) {
            throw new DatabaseInitializationFailureException("Failure to migrate database", e);
        }
    }

    private int findDatabaseVersion(Connection connection) {
        try {
            DatabaseMetaData metadata = connection.getMetaData();
            try (ResultSet rs = metadata.getTables(null, null, "DBVERSION", null)) {
                if (!rs.next()) {
                    return 0;
                }
            }
            // DBVERSION exists
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("select max(VERSION) as VERSION from DBVERSION")) {
                if (rs.next()) {
                    return rs.getInt("VERSION");
                } else {
                    throw new DatabaseInitializationFailureException("No versions in DBVERSION");
                }
            }
        } catch (SQLException e) {
            throw new DatabaseInitializationFailureException("Unable to determine database version", e);
        }
    }

    private void createDatabase() {
        try {
            databaseInfo.createDatabaseIfNecessary();
        } catch (SQLException e) {
            throw new DatabaseInitializationFailureException("Failed to create database", e);
        }
    }

    @Slf4j
    private static class MigrationStep {

        private final int version;
        private final Connection connection;
        private final String[] statements;

        MigrationStep(int version, Connection connection, String... statements) {
            this.version = version;
            this.connection = connection;
            this.statements = statements;
        }

        void migrate() {
            log.info("Migrating to version {}", version);
            try (Statement statement = connection.createStatement()) {
                for (String statementString : statements) {
                    // Special consideration to force commits, will break transactionality of migration
                    if (statementString.equalsIgnoreCase("commit")) {
                        connection.commit();
                        continue;
                    }
                    statement.execute(statementString);
                }

                try (PreparedStatement pstmt = connection.prepareStatement(
                        "insert into dbversion(version, migration_date) values (?, current_timestamp)")) {
                    pstmt.setInt(1, version);
                    pstmt.execute();
                }

                connection.commit();
            } catch (SQLException e) {
                try {
                    connection.rollback();
                } catch (SQLException e2) {
                    log.error("Failed to rollback step {}", version, e2);
                }
                throw new DatabaseInitializationFailureException("Failed in step " + version, e);
            }
            log.info("Migration to version {} completed", version);
        }
    }
}

